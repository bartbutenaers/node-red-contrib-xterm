<!--
  Copyright 2019, Bart Butenaers
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<script src="xterm_shell/undefined/js/xterm.js"></script>
<script src="xterm_shell/undefined/js/xterm-addon-fit.js"></script>

<script type="text/javascript">
	const defaultRows = 60;
	const defaultColumns = 120;
	
    RED.nodes.registerType('xterm_config', {
        category: 'config',
        defaults: {
            rows: {value: defaultRows, required: true},
            columns: {value: defaultColumns, required: true},
            startupCommand: {value: "cd $HOME/.node-red"},
            cursorStyle: {value: "bar"},
            fastScrollModifier: {value: "alt"},
            scrollSensitivity: {value: 1},
            fastScrollSensitivity: {value: 1},
            scrollback: {value: 1000},
            backgroundColor: {value: "#000000"},
            foregroundColor: {value: "#ffffff"},
            fontSize: {value: 12},
            cursorBlink: {value: true},
            drawBoldTextInBrightColors: {value: true},
            loggingEnabled: {value: false},
            name: { value: "" }
        },
        label: function () {
            return this.name;
        },
        onpaletteremove: function () {
            RED.sidebar.removeTab("sidebar-xterm");
            /*RED.events.off("deploy", deployEventHandler);
            RED.events.off("sidebar:resize", sidebarresizeEventHandler);
            RED.events.off("view:selection-changed", nodeSelectEventHandler);
            RED.events.off("workspace:change", flowSelectEventHandler);*/
        },
        onpaletteadd: function () {
			var globalTerminalConfigNode = null;
			var node = this;
			
			debugger;
			
			function startTerminal() {
				// Pass the default rows and columns as 'info' parameter
				var info = defaultRows + ";" + defaultColumns;

			    // Start the pty pseudo terminal process on the server side
				$.getJSON("xterm_shell/" + node.terminalId + "/start/" + info, function(result){
					// The terminal look-and-feel will be based on the user settings (in the globalTerminalConfigNode).
					// We use the rows and columns from the result, because that are the rows and columns that have been used to start
					// the pseudo terminal process on the server.  That way the Xterm.js terminal window dimensions will always mach.
					// Remark: the rows and columns in the globalTerminalConfigNode will be used (on the server side to start the pseudo
					// terminal process), when that config node has already been deployed.  Which means we get then the 
					// globalTerminalConfigNode also here via a long roundtrip to the server ...
					var terminalOptions = {
						rows: parseInt(result.rows),
						cols: parseInt(result.columns),
						cursorStyle: globalTerminalConfigNode.cursorStyle,
						fastScrollModifier: globalTerminalConfigNode.fastScrollModifier,
						scrollback: globalTerminalConfigNode.scrollback,
						scrollSensitivity: globalTerminalConfigNode.scrollSensitivity,
						fastScrollSensitivity: globalTerminalConfigNode.fastScrollSensitivity,
						fontSize: globalTerminalConfigNode.fontSize,
						cursorBlink: globalTerminalConfigNode.cursorBlink,
						drawBoldTextInBrightColors: globalTerminalConfigNode.drawBoldTextInBrightColors,
						theme: {
							background: globalTerminalConfigNode.backgroundColor,
							foreground: globalTerminalConfigNode.foregroundColor
						},
						useStyle: true,
						screenKeys: true,
						fontFamily: 'Courier New'
					};
					
					var terminalContainer = document.getElementById('terminalContainer');
					
					node.terminal = new Terminal(terminalOptions);
			 
					// Show the terminal inside the specified DIV element
					node.terminal.open(terminalContainer);

					node.terminal.onData(function(data) {
						sendDataToServer(data);
					});
				 
					// Handle data that arrives from the server via the websocket channel
					node.handleDataFromServer = function(event, dataAsString) {
						var data = JSON.parse(dataAsString);
						
						// Only show data that is intended for this terminal
						if (data.terminalId === node.terminalId) { 
							if (node.loggingEnabled) {
								var contentType = Object.prototype.toString.call(data.content);
								console.log("Terminal data from server (type = " + contentType + "): " + data);
							}
							
							var decodedString;
						
							// Convert the base64 encoded string back to a string
							// Only content type "data" is base64 encode, the other types (error, info, ...) not!
							if (data.type === "data") {
								decodedString = atob(data.content);
							}
							else {
								decodedString = data.content;
							}
								
							node.terminal.write(decodedString);
							
							// Handle the startup command once, after the first prompt has been received (to make sure everything arrives in the correct sequence)
							if (!node.isStartupHandled) {
								node.isStartupHandled = true;
							
								if (node.startupCommand &&  node.startupCommand!== "") {
									// Pass an enter (\n) after the startup command to execute it immediately
									sendDataToServer(node.terminalId, node.startupCommand + "\n");
								}
							}
						}
					}
					
					RED.comms.subscribe('xterm_shell', node.handleDataFromServer);
					
					// Created with http://www.asciiarts.net/ where I used font 'Standard.flf'
					// TODO for some reason it doesn't show clearly : see font in constructor and in DIV element style
					//node.terminal.write('\r\n***  _   _           _            ____  _____ ____   ***');
					//node.terminal.write('\r\n*** | \ | | ___   __| | ___      |  _ \| ____|  _ \  ***');
					//node.terminal.write('\r\n*** |  \| |/ _ \ / _` |/ _ \_____| |_) |  _| | | | | ***');
					//node.terminal.write('\r\n*** | |\  | (_) | (_| |  __/_____|  _ <| |___| |_| | ***');
					//node.terminal.write('\r\n*** |_| \_|\___/ \__,_|\___|     |_| \_\_____|____/  ***');
					//node.terminal.write('\r\n'); 
				});
			}
			
			function stopTerminal() {
				if (node.terminal) {
					// Stop the xterm terminal on the client side (remark 'destroy' has been removed...)
					node.terminal.dispose(); 
				}
				
				// Stop the pty process on the server side
				$.ajax( {url: "xterm_shell/" + node.terminalId +"/stop/undefined" } );
				
				if (node.handleWebsocketData) {
					RED.comms.unsubscribe('xterm_shell', node.handleWebsocketData);
				}
			}
            
            function sendDataToServer(data) {
                if (node.loggingEnabled) {
                    var dataType = Object.prototype.toString.call(data);
                    console.log("Terminal data to server (type = " + dataType + "): " + data);
                }
                
                // Convert the data to base64 to make sure that spaces, newlines, ... don't get lost during transport
                var base64Data = btoa(data);
                $.ajax( {url: "xterm_shell/" + node.terminalId + "/write/" + base64Data} );
            }
			
			// See https://www.w3resource.com/javascript-exercises/javascript-math-exercise-23.php
            function createUUID(){
                var dt = new Date().getTime();
                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = (dt + Math.random()*16)%16 | 0;
                    dt = Math.floor(dt/16);
                    return (c=='x' ? r :(r&0x3|0x8)).toString(16);
                });
                return uuid;
            }
			
			// Check whether the globalTerminalConfigNode (still) exists
			function ensureTerminalConfigNode(createMissing) {
                // If we had find it previously, check if it has been deleted beneath us
				if (globalTerminalConfigNode !== null) {
                    var n = RED.nodes.node(globalTerminalConfigNode.id);
                    if (n === null) { globalTerminalConfigNode = null; }
                }
				
				// If not found previously, let's go find it
				if (globalTerminalConfigNode === null) {
					var configNodes = [];
					RED.nodes.eachConfig(function(n) {
						if (n.type === 'xterm_config') { configNodes.push(n); }
					});
					
					// Make sure we only have 1 config node
					while (configNodes.length > 1) {
                        var n = bases.pop();
                        RED.nodes.remove(n.id);
                        RED.nodes.dirty(true);
                    }
					
					// When we found a config node, let's use that one
					if (configNodes.length === 1) { globalTerminalConfigNode = configNodes[0]; }
				}
				
				// When it doesn't exist yet, create it if required
				if (globalTerminalConfigNode === null && createMissing) {
					// TODO controleren of de defaults door de config node code zelf toegepast worden????
					globalTerminalConfigNode = {
                        id: RED.nodes.id(),
                        _def: RED.nodes.getType("xterm_config"),
                        type: "xterm_config",
						hasUsers: true, // To make sure the config node will not be considered as "unused"
                        users: [],
						rows: 60,
            			columns: 120,
            			startupCommand: "cd $HOME/.node-red",
            			cursorStyle: "bar",
            			fastScrollModifier: "alt",
            			scrollSensitivity: 1,
            			fastScrollSensitivity: 1,
            			scrollback: 1000,
            			backgroundColor: "#000000",
            			foregroundColor: "#ffffff",
            			fontSize: 12,
            			cursorBlink: true,
            			drawBoldTextInBrightColors: true,
            			loggingEnabled: false,
            			name: ""
                    }
					
					// Add the new config node to the collection of Node-RED nodes
                    RED.nodes.add(globalTerminalConfigNode);
					
					// Make sure the "Deploy" button becomes active
					RED.nodes.dirty(true);
				}
			}
			
			// Make sure there is a config node available when we get started ...
			ensureTerminalConfigNode(true);
		
            var content = $("<div/>",{
                id:"tab-terminal-xterm", style:"position: relative; padding: 0px 4px; height: 100%; overflow: hidden"
            });
			
			// Load the sidebar html file
			// See https://stackoverflow.com/questions/18938180/how-to-get-the-html-of-a-div-on-another-page-with-jquery-ajax
			$.ajax({
				url: "xterm_shell/undefined/html/sidebar.html",
				type:'GET',
				success: function(data){
					// Show the external html file as sidebar content
					content.append(data);

					// Once the container DIV element has been created, the terminal can be displayed as a child element
					// Edit: we will ask the user to manually start the terminal, instead of 
					//startTerminal();
					
					$("#node-start-terminal").on("click", function (e) {
						if (node.terminal) {
							alert("The terminal has already been started");
						}
						else {
							startTerminal();
						}							
					});
					
					$("#node-stop-terminal").on("click", function (e) {
						if (!node.terminal) {
							alert("The terminal was already stopped");
						}
						else {
							stopTerminal();
						}						
					});

					$("#node-clear-terminal").on("click", function (e) {
						node.terminal.clear();      
					});					
					
					// Show tabsheets
					node.tabs = RED.tabs.create({
						id: "node-xterm-tabs",
						onchange: function(tab) {
							// Show only the content (i.e. the children) of the selected tabsheet, and hide the others
							$("#node-xterm-tabs-content").children().hide();
							$("#" + tab.id).show();
							
							if (tab.id === "node-xterm-tab-terminal") {
								// TODO auto focus doesn't work ...
		 // TODO                       node.terminal.focus();
							}
						}
					});
					
					node.tabs.addTab({
						id: "node-xterm-tab-terminal",
						label: "Terminal"
					});
					
					node.tabs.addTab({
						id: "node-xterm-tab-settings",
						label: "Settings"
					});

					// For every setting input field, we will have to store the changed values into the config node
					$(".xterm-setting").on("change", function() {
						var propertyName = this.id.replace("node-config-input-", "");
						var propertyValue = $(this).val();
						
						if (this.type === "checkbox") {
							// For checkboxes we don't want to use the on/off values, but instead true/false
							propertyValue = this.checked;
						}
			
						// When the property value has changed, save it in the config node and activate the 'deploy' button.
						// Remark: don't check the input type (i.e. use != instead of  !==) because we will get the number values as strings...
						if (!globalTerminalConfigNode || globalTerminalConfigNode[propertyName] != propertyValue) {
							ensureTerminalConfigNode(true);
							globalTerminalConfigNode[propertyName] = propertyValue;
							RED.nodes.dirty(true);
						}
					})		

					// At startup we should display all the config node properties into the corresponding input fields
					$('.xterm-setting').each(function() {
						var propertyName = $(this).get(0).id.replace("node-config-input-", "");
						var propertyValue = globalTerminalConfigNode[propertyName];
						
						if ($(this)[0].type === "checkbox") {
							$(this).attr("checked", propertyValue);
						}
						else {
							$(this).val(propertyValue);
						}
					});	
				}
			});
			
			// Add a new "Terminal" tabsheet to the sidebar in the flow editor
            RED.sidebar.addTab({
                id: "sidebar-xterm",
                label: "terminal_xterm",
                name: "Terminal",
                content: content,
                closeable: true,
                disableOnEdit: true,
                iconClass: "fa fa-terminal",
                onchange: function() { 
                    // Need to wait for it to be rendered before the sizing of the tabs
                    // can be properly calculated
                    //setTimeout(sidebarresizeEventHandler, 0);
                 }
            });
            
            /*RED.events.on("deploy", deployEventHandler);
            RED.events.on("sidebar:resize", sidebarresizeEventHandler);
            RED.events.on("view:selection-changed", nodeSelectEventHandler);
            RED.events.on("workspace:change", flowSelectEventHandler);*/
                
            // Multiple flow editors can be open simultaneously, which means multiple terminals can be open simultaneously.
            // All of these terminals need to work completely independent from each: we don't want the data from these terminals
            // to become mixed!  We will generate a unique id, to identify this flow editor instance in all communication with the server.
            node.terminalId = createUUID();

			// Add the xterm.js CSS stylesheet to the page head section
            $('head').append('<link rel="stylesheet" href="xterm_shell/undefined/css/xterm.css" type="text/css" />');
			
			if (node.timerId) {
				clearInterval(node.timerId);
				node.timerId = null;
			}
			
			// When the flow editor is closed, the corresponding pseudo terminal process (on server side) should be killed.
			// However it seems there is no way to determine that on the server side, see:
			// https://discourse.nodered.org/t/detect-when-flow-editor-is-closed/18357/3?u=bartbutenaers
			// Therefore we will send a heartbeat every 5 seconds to the server.
			node.timerId = setInterval(function() {
				$.ajax( {url: "xterm_shell/" + node.terminalId +"/heartbeat/undefined" } );
			}, 5000);
        }
    });
</script>

<script type="text/x-red" data-template-name="xterm_config">
    <div class="form-row">
        <label for="node-config-input-startupCommand"><i class="icon-tag"></i> Start command</label>
        <input type="text" id="node-config-input-startupCommand" placeholder="cd $HOME/.node-red">
    </div>
    <div class="form-row">
        <label for="node-config-input-rows"><i class="fa fa-arrows-alt"></i> Grid</label>
        <span for="node-config-input-rows">Rows</span>
        <input type="text" id="node-config-input-rows" style="width:80px" min="1">
        <span for="node-config-input-columns" style="margin-left:20px;"> Columns</span>
        <input type="text" id="node-config-input-columns" style="width:80px" min="1">
    </div>
    <div class="form-row">
        <label for="node-config-input-cursorStyle"><i class="fa fa-terminal"></i> Cursor style</label>
        <select id="node-config-input-cursorStyle">
            <option value="block">Block</option> 
            <option value="underline">Underline</option>
            <option value="bar">Bar</option>
        </select>
    </div>
    <div class="form-row">
        <label for="node-config-input-fastScrollModifier"><i class="fa fa-keyboard-o"></i> Fast scroll key</label>
        <select id="node-config-input-fastScrollModifier">
            <option value="alt">Alt</option> 
            <option value="ctrl">Ctrl</option>
            <option value="shift">Shift</option>
            <option value="undefined">Undefined</option>
        </select>
    </div>            
    <div class="form-row">
        <label for="node-config-input-scrollback"><i class="fa fa-arrows-v"></i> Scrollback</label>
        <input type="text" id="node-config-input-scrollback" min="0">
    </div>
    <div class="form-row">
        <label for="node-config-input-backgroundColor"><i class="fa fa-paint-brush"></i> Background</span></label>
        <input type="color" id="node-config-input-backgroundColor"/>
    </div>
    <div class="form-row">
        <label for="node-config-input-foregroundColor"><i class="fa fa-paint-brush"></i> Foreground</span></label>
        <input type="color" id="node-config-input-foregroundColor"/>
    </div>
    <div class="form-row">
        <label for="node-config-input-scrollSensitivity"><i class="fa fa-tachometer"></i> Scroll</label>
        <input type="text" id="node-config-input-scrollSensitivity" min="1" max="10">
    </div>
    <div class="form-row">
        <!-- See https://github.com/xtermjs/xterm.js/pull/2375 -->
        <label for="node-config-input-fastScrollSensitivity"><i class="fa fa-tachometer"></i> Fast scroll</label>
        <input type="text" id="node-config-input-fastScrollSensitivity" min="1" max="10">
    </div>
    <div class="form-row">
        <label for="node-config-input-fontSize"><i class="fa fa-tachometer"></i> Font size</label>
        <input type="text" id="node-config-input-fontSize" min="1" max="20">
    </div>
    <div class="form-row">
        <input type="checkbox" id="node-config-input-cursorBlink" style="display: inline-block; width: auto; vertical-align: top;">
        <label for="node-config-input-cursorBlink" style="width:70%;"> Blinking cursor</label>
    </div>          
    <div class="form-row">
        <input type="checkbox" id="node-config-input-drawBoldTextInBrightColors" style="display: inline-block; width: auto; vertical-align: top;">
        <label for="node-config-input-drawBoldTextInBrightColors" style="width:70%;"> Draw bold text in bright colors</label>
    </div>   
    <div class="form-row">
        <input type="checkbox" id="node-config-input-loggingEnabled" style="display: inline-block; width: auto; vertical-align: top;">
        <label for="node-config-input-loggingEnabled" style="width:70%;"> Enable detailed logging (for troubleshooting)</label>
    </div>               
    </br>
    <div class="form-row">
        <label for="node-config-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-config-input-name" placeholder="Name">
    </div>
</script>

<script type="text/x-red" data-help-name="xterm_config">
    <p>Configuration for an Xterm terminal screen.</p>
    <p><strong>Start command:</strong><br/>
    Command that need to be executed automatically when the terminal is started.</p>
    <p><strong>Grid:</strong><br/>
    The number of rows and columns that need to be displayed inside the terminal.  Both characteristcs are specified in number of characters.</p>
    <p><strong>Cursor style:</strong><br/>
    Specifies how the cursor should be displayed.</p>    
    <p><strong>Fast scroll key:</strong><br/>
    The modifier key hold to multiply scroll speed.</p>                 
    <p><strong>Scrollback:</strong><br/>
    The number of rows that are retained when lines are scrolled beyond the initial viewport.</p>               
    <p><strong>Background:</strong><br/>
    The background color of the terminal window.</p>             
    <p><strong>Foreground:</strong><br/>
    The foreground color of the text on the terminal window.</p>              
    <p><strong>Scroll:</strong><br/>
    The scroll speed multiplier used for scrolling..</p>                         
    <p><strong>Fast scroll:</strong><br/>
    The scroll speed multiplier used for fast scrolling..</p>                   
    <p><strong>Blinking cursor :</strong><br/>
    Whether the cursor should be blinking or not.</p>     
    <p><strong>Draw bold text in bright colors:</strong><br/>
    Whether to draw bold text in bright colors.</p>  
    <p><strong>Enable data logging:</strong><br/>
    Enable logging of all the data being send (both on client and server side), to simplify troubleshooting in case of problems.</p>     
</script>
